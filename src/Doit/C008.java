package Doit;

public class C008 {
	/**
	 * @author 김은호
	 * @since 2024. 1. 22.오후 11:00:24
	 * @category 백준1253
	 * @class 골드4
	 * @see N개의 수 중에서 어떤 수가 다른 수 두 개의 합으로 나타낼 수 있다면 그 수를 “좋다(GOOD)”고 한다.
	 * 
	 *      N개의 수가 주어지면 그 중에서 좋은 수의 개수는 몇 개인지 출력하라.
	 * 
	 *      수의 위치가 다르면 값이 같아도 다른 수이다.
	 * @input 첫째 줄에는 수의 개수 N(1 ≤ N ≤ 2,000), 두 번째 줄에는 i번째 수를 나타내는 Ai가 N개 주어진다.
	 * 
	 *        (|Ai| ≤ 1,000,000,000, Ai는 정수)
	 * 
	 *        10
	 * 
	 *        1 2 3 4 5 6 7 8 9 10
	 * @output 좋은 수의 개수를 첫 번째 줄에 출력한다. 8
	 */
	/**
	 * @이해완료시간 2024. 1. 22. 오후 11:07:16 완료
	 * @문제분석하기 시간 복잡도부터 생각해 본다. n개의 개수가 최대 2000 이라 가정해도 좋은 수 하나를 찾는 알고리즘의 시간 복잡도는 N의
	 *         제곱보다 작아야한다.
	 * 
	 *         만약 시간 복잡도가 N^2인 알고리즘을 사용하면 최종 시간 복잡도는 N^3이 되어 제한시간안에 문제를 풀 수없기 때문이다.
	 * 
	 *         따라서 좋은 수하나를 찾는 알고리즘의 시간 복잡도는 최소 O(nlog)여야한다. 정렬, 투포인터 알고리즘을 사용하면 된다.
	 * 
	 *         단 정렬된 데이터에서 자기 자신을 좋은 수 만들기에 포함하면 2개의 수가 아닌 1개의 수만 가지므로 이를 예외로 두어야한다.
	 * @내용 수를 입력받아 배열에 저장한 후 정렬을 시킨다.
	 * 
	 *     투포인터 r,l을 배열 A양쪽 끝에 위치시키고 조건에 적합한 투 포인터 이동 원칙을 활용해 탐색을 수행한다. 판별의 대상이 되는
	 *     수는 K라고 가정한다.
	 * 
	 *     (S>U)=> l--,(S<U)=>r++,(S==U)=>C++ r++ l--
	 * 
	 *     그리고 위의 단계를 배여르이 모든 수에 대하여 반복해 줄 수 있도록 한다. 즉 계속 비교하고있는 값인 K가 N이 될떄까지 반복하며
	 *     좋은 수가 몇개인지 찾는다.
	 */
	/**
	 * @슈도코드작성하기 
	 * @슈도코드
	 */
	/**
	 * @결과
	 * @시간
	 */
	public static void main(String[] args) {

	}
}
